{
  "problems": [
    {
      "id": 1,
      "title": "Meeting Rooms I",
      "difficulty": "Easy",
      "topic": "Array, Sorting, Intervals",
      "description": "Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.",
      "algorithm": {
        "approach": "Sort by Start Time",
        "steps": [
          "Sort intervals by start time",
          "Check if any two consecutive intervals overlap",
          "Return false if overlap found, true otherwise"
        ],
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(1)"
  },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    bool canAttendMeetings(vector<vector<int>>& intervals) {\n        if (intervals.size() <= 1) return true;\n        \n        // Sort by start time\n        sort(intervals.begin(), intervals.end());\n        \n        // Check for overlaps\n        for (int i = 1; i < intervals.size(); i++) {\n            if (intervals[i][0] < intervals[i-1][1]) {\n                return false; // Overlap found\n            }\n        }\n        \n        return true;\n    }\n};"
      },
      "examples": [
        {
          "input": "intervals = [[0,30],[5,10],[15,20]]",
          "output": "false",
          "explanation": "Cannot attend all meetings because [0,30] overlaps with [5,10] and [15,20]"
        },
        {
          "input": "intervals = [[7,10],[2,4]]",
          "output": "true",
          "explanation": "No overlapping meetings, can attend all"
        }
      ]
    },
    {
      "id": 2,
      "title": "Minimum Size Subarray Sum",
      "difficulty": "Medium",
      "topic": "Array, Sliding Window, Two Pointers",
      "description": "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target.",
      "algorithm": {
        "approach": "Sliding Window",
        "steps": [
          "Use two pointers (left, right) for sliding window",
          "Expand window by moving right pointer",
          "When sum >= target, try to shrink from left",
          "Track minimum window size found"
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        int left = 0, sum = 0, minLen = INT_MAX;\n        \n        for (int right = 0; right < nums.size(); right++) {\n            sum += nums[right];\n            \n            // Shrink window while sum >= target\n            while (sum >= target) {\n                minLen = min(minLen, right - left + 1);\n                sum -= nums[left++];\n            }\n        }\n        \n        return minLen == INT_MAX ? 0 : minLen;\n    }\n};"
      },
      "examples": [
        {
          "input": "target = 7, nums = [2,3,1,2,4,3]",
          "output": "2",
          "explanation": "Subarray [4,3] has minimal length and sum >= 7"
        },
        {
          "input": "target = 4, nums = [1,4,4]",
          "output": "1",
          "explanation": "Single element [4] satisfies the condition"
        }
      ]
    },
    {
      "id": 3,
      "title": "Find All Anagrams",
      "difficulty": "Medium",
      "topic": "Hash Table, String, Sliding Window",
      "description": "Given two strings s and p, return an array of all the start indices of p's anagrams in s.",
      "algorithm": {
        "approach": "Sliding Window with Character Count",
        "steps": [
          "Create frequency map for pattern p",
          "Use sliding window of size p.length() on string s",
          "Compare character frequencies in current window",
          "Add start index when frequencies match"
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        vector<int> result;\n        if (s.size() < p.size()) return result;\n        \n        vector<int> pCount(26, 0), sCount(26, 0);\n        \n        // Count chars in p and first window of s\n        for (int i = 0; i < p.size(); i++) {\n            pCount[p[i] - 'a']++;\n            sCount[s[i] - 'a']++;\n        }\n        \n        if (pCount == sCount) result.push_back(0);\n        \n        // Slide window\n        for (int i = p.size(); i < s.size(); i++) {\n            sCount[s[i] - 'a']++; // Add new char\n            sCount[s[i - p.size()] - 'a']--; // Remove old char\n            \n            if (pCount == sCount) {\n                result.push_back(i - p.size() + 1);\n            }\n        }\n        \n        return result;\n    }\n};"
      },
      "examples": [
        {
          "input": "s = \"abab\", p = \"ab\"",
          "output": "[0,2]",
          "explanation": "Anagrams of \"ab\" start at indices 0 and 2"
        },
        {
          "input": "s = \"abacabad\", p = \"aaab\"",
          "output": "[0]",
          "explanation": "Only one anagram found at index 0"
        }
      ]
    },
    {
      "id": 4,
      "title": "Longest Substring Without Repeating",
      "difficulty": "Medium",
      "topic": "Hash Table, String, Sliding Window",
      "description": "Given a string s, find the length of the longest substring without repeating characters.",
      "algorithm": {
        "approach": "Sliding Window with Hash Set",
        "steps": [
          "Use two pointers for sliding window",
          "Expand window by moving right pointer",
          "When duplicate found, shrink from left until no duplicates",
          "Track maximum window size"
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(min(m,n))"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_set<char> seen;\n        int left = 0, maxLen = 0;\n        \n        for (int right = 0; right < s.size(); right++) {\n            // Shrink window until no duplicate\n            while (seen.count(s[right])) {\n                seen.erase(s[left++]);\n            }\n            \n            seen.insert(s[right]);\n            maxLen = max(maxLen, right - left + 1);\n        }\n        \n        return maxLen;\n    }\n};"
      },
      "examples": [
        {
          "input": "s = \"abcabcbb\"",
          "output": "3",
          "explanation": "\"abc\" is the longest substring without repeating characters"
        },
        {
          "input": "s = \"bbbbb\"",
          "output": "1",
          "explanation": "\"b\" is the longest substring without repeating characters"
        }
      ]
    },
    {
      "id": 5,
      "title": "Serialize and Deserialize Binary Tree",
      "difficulty": "Hard",
      "topic": "String, Tree, DFS, BFS, Binary Tree",
      "description": "Design an algorithm to serialize and deserialize a binary tree. Serialization is converting a tree to a string. Deserialization is constructing the tree from the string.",
      "algorithm": {
        "approach": "Preorder DFS with Null Markers",
        "steps": [
          "Serialize: Use preorder traversal, mark nulls with special character",
          "Deserialize: Parse string and reconstruct using preorder",
          "Use queue/index to track position during reconstruction"
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Codec {\npublic:\n    // Encodes tree to string\n    string serialize(TreeNode* root) {\n        string result;\n        serializeHelper(root, result);\n        return result;\n    }\n    \n    void serializeHelper(TreeNode* node, string& s) {\n        if (!node) {\n            s += \"null,\";\n            return;\n        }\n        s += to_string(node->val) + \",\";\n        serializeHelper(node->left, s);\n        serializeHelper(node->right, s);\n    }\n    \n    // Decodes string to tree\n    TreeNode* deserialize(string data) {\n        queue<string> q;\n        stringstream ss(data);\n        string item;\n        \n        // Parse comma-separated values\n        while (getline(ss, item, ',')) {\n            q.push(item);\n        }\n        \n        return deserializeHelper(q);\n    }\n    \n    TreeNode* deserializeHelper(queue<string>& q) {\n        string val = q.front();\n        q.pop();\n        \n        if (val == \"null\") return nullptr;\n        \n        TreeNode* node = new TreeNode(stoi(val));\n        node->left = deserializeHelper(q);\n        node->right = deserializeHelper(q);\n        return node;\n    }\n};"
      },
      "examples": [
        {
          "input": "root = [1,2,3,null,null,4,5]",
          "output": "[1,2,3,null,null,4,5]",
          "explanation": "Tree serialized and deserialized correctly"
        },
        {
          "input": "root = []",
          "output": "[]",
          "explanation": "Empty tree handled correctly"
        }
      ]
    },
    {
      "id": 6,
      "title": "Reverse Nodes in k-Group",
      "difficulty": "Hard",
      "topic": "Linked List, Recursion",
      "description": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.",
      "algorithm": {
        "approach": "Iterative Reversal",
        "steps": [
          "Check if we have k nodes to reverse",
          "Reverse k nodes using standard reversal technique",
          "Connect reversed group to previous and next parts",
          "Move to next group"
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if (!head || k == 1) return head;\n        \n        // Check if we have k nodes\n        ListNode* curr = head;\n        for (int i = 0; i < k; i++) {\n            if (!curr) return head;\n            curr = curr->next;\n        }\n        \n        // Reverse first k nodes\n        ListNode* prev = nullptr;\n        curr = head;\n        for (int i = 0; i < k; i++) {\n            ListNode* next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        \n        // Connect with rest\n        head->next = reverseKGroup(curr, k);\n        return prev;\n    }\n};"
      },
      "examples": [
        {
          "input": "head = [1,2,3,4,5], k = 2",
          "output": "[2,1,4,3,5]",
          "explanation": "Reverse every 2 nodes"
        }
      ]
    },
    {
      "id": 7,
      "title": "Number of Islands",
      "difficulty": "Medium",
      "topic": "Array, DFS, BFS, Matrix",
      "description": "Given an m x n 2D binary grid which represents a map of '1's (land) and '0's (water), return the number of islands.",
      "algorithm": {
        "approach": "DFS/BFS",
        "steps": [
          "Iterate through each cell in the grid",
          "When land ('1') is found, increment island count",
          "Use DFS/BFS to mark all connected land as visited",
          "Continue until all cells are processed"
        ],
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(m*n)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        if (grid.empty()) return 0;\n        \n        int m = grid.size(), n = grid[0].size();\n        int islands = 0;\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    islands++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        \n        return islands;\n    }\n    \nprivate:\n    void dfs(vector<vector<char>>& grid, int i, int j) {\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] != '1') {\n            return;\n        }\n        \n        grid[i][j] = '0'; // Mark as visited\n        dfs(grid, i+1, j);\n        dfs(grid, i-1, j);\n        dfs(grid, i, j+1);\n        dfs(grid, i, j-1);\n    }\n};"
      },
      "examples": [
        {
          "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
          "output": "1",
          "explanation": "One large island"
        }
      ]
    },
    {
      "id": 8,
      "title": "Word Ladder",
      "difficulty": "Hard",
      "topic": "Hash Table, String, BFS",
      "description": "Given two words, beginWord and endWord, and a dictionary wordList, return the length of the shortest transformation sequence from beginWord to endWord.",
      "algorithm": {
        "approach": "BFS",
        "steps": [
          "Use BFS to find shortest path",
          "For each word, try changing each character",
          "Check if new word exists in dictionary",
          "Continue until endWord is found"
        ],
        "timeComplexity": "O(M^2 * N)",
        "spaceComplexity": "O(M^2 * N)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        unordered_set<string> dict(wordList.begin(), wordList.end());\n        if (!dict.count(endWord)) return 0;\n        \n        queue<string> q;\n        q.push(beginWord);\n        int level = 1;\n        \n        while (!q.empty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                string word = q.front();\n                q.pop();\n                \n                if (word == endWord) return level;\n                \n                // Try all possible transformations\n                for (int j = 0; j < word.length(); j++) {\n                    char orig = word[j];\n                    for (char c = 'a'; c <= 'z'; c++) {\n                        word[j] = c;\n                        if (dict.count(word)) {\n                            dict.erase(word);\n                            q.push(word);\n                        }\n                    }\n                    word[j] = orig;\n                }\n            }\n            level++;\n        }\n        \n        return 0;\n    }\n};"
      },
      "examples": [
        {
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "output": "5",
          "explanation": "hit -> hot -> dot -> dog -> cog"
        }
      ]
    },
    {
      "id": 9,
      "title": "Edit Distance",
      "difficulty": "Medium",
      "topic": "String, Dynamic Programming",
      "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.",
      "algorithm": {
        "approach": "Dynamic Programming",
        "steps": [
          "Create DP table dp[i][j] for first i chars of word1, first j chars of word2",
          "If characters match, dp[i][j] = dp[i-1][j-1]",
          "Otherwise, take min of insert, delete, replace operations",
          "Return dp[m][n]"
        ],
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(m*n)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.length(), n = word2.length();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n        \n        // Base cases\n        for (int i = 0; i <= m; i++) dp[i][0] = i;\n        for (int j = 0; j <= n; j++) dp[0][j] = j;\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (word1[i-1] == word2[j-1]) {\n                    dp[i][j] = dp[i-1][j-1];\n                } else {\n                    dp[i][j] = 1 + min({dp[i-1][j],    // delete\n                                        dp[i][j-1],    // insert\n                                        dp[i-1][j-1]}); // replace\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n};"
      },
      "examples": [
        {
          "input": "word1 = \"horse\", word2 = \"ros\"",
          "output": "3",
          "explanation": "horse -> rorse -> rose -> ros"
        }
      ]
    },
    {
      "id": 10,
      "title": "LRU Cache",
      "difficulty": "Medium",
      "topic": "Hash Table, Linked List, Design",
      "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.",
      "algorithm": {
        "approach": "HashMap + Doubly Linked List",
        "steps": [
          "Use HashMap for O(1) access to nodes",
          "Use doubly linked list to maintain order",
          "Move accessed nodes to head",
          "Remove tail when capacity exceeded"
        ],
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(capacity)"
      },
      "code": {
        "language": "cpp",
        "solution": "class LRUCache {\n    struct Node {\n        int key, val;\n        Node* prev, *next;\n        Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n    };\n    \n    unordered_map<int, Node*> mpp;\n    Node* head, *tail;\n    int cap;\n    \npublic:\n    LRUCache(int capacity) : cap(capacity) {\n        head = new Node();\n        tail = new Node();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if (!mpp.count(key)) return -1;\n        \n        Node* node = mpp[key];\n        moveToHead(node);\n        return node->val;\n    }\n    \n    void put(int key, int value) {\n        if (mpp.count(key)) {\n            Node* node = mpp[key];\n            node->val = value;\n            moveToHead(node);\n        } else {\n            Node* node = new Node(key, value);\n            mpp[key] = node;\n            addToHead(node);\n            \n            if (mpp.size() > cap) {\n                Node* last = removeTail();\n                mpp.erase(last->key);\n                delete last;\n            }\n        }\n    }\n    \nprivate:\n    void addToHead(Node* node) {\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(Node* node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n    \n    void moveToHead(Node* node) {\n        removeNode(node);\n        addToHead(node);\n    }\n    \n    Node* removeTail() {\n        Node* last = tail->prev;\n        removeNode(last);\n        return last;\n    }\n};"
      },
      "examples": [
        {
          "input": "LRUCache(2); put(1,1); put(2,2); get(1); put(3,3); get(2); put(4,4); get(1); get(3); get(4)",
          "output": "[null,null,null,1,null,-1,null,-1,3,4]",
          "explanation": "Cache operations with capacity 2"
        }
      ]
    },
    {
      "id": 11,
      "title": "Merge Intervals",
      "difficulty": "Medium",
      "topic": "Array, Sorting",
      "description": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals.",
      "algorithm": {
        "approach": "Sort and Merge",
        "steps": [
          "Sort intervals by start time",
          "Iterate and merge overlapping intervals",
          "Update end time when overlapping",
          "Add non-overlapping intervals to result"
        ],
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(1)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        if (intervals.empty()) return {};\n        \n        sort(intervals.begin(), intervals.end());\n        vector<vector<int>> result;\n        \n        for (auto& interval : intervals) {\n            // No overlap, add new interval\n            if (result.empty() || result.back()[1] < interval[0]) {\n                result.push_back(interval);\n            } else {\n                // Overlap, merge intervals\n                result.back()[1] = max(result.back()[1], interval[1]);\n            }\n        }\n        \n        return result;\n    }\n};"
      },
      "examples": [
        {
          "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
          "output": "[[1,6],[8,10],[15,18]]",
          "explanation": "[1,3] and [2,6] overlap, merge to [1,6]"
        }
      ]
    },
    {
      "id": 12,
      "title": "Best Time to Buy and Sell Stock",
      "difficulty": "Easy",
      "topic": "Array, Dynamic Programming",
      "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.",
      "algorithm": {
        "approach": "One Pass",
        "steps": [
          "Track minimum price seen so far",
          "For each price, calculate profit if sold today",
          "Update maximum profit found",
          "Update minimum price"
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int minPrice = INT_MAX, maxProfit = 0;\n        \n        for (int price : prices) {\n            // Update max profit if selling today\n            maxProfit = max(maxProfit, price - minPrice);\n            // Update min price seen so far\n            minPrice = min(minPrice, price);\n        }\n        \n        return maxProfit;\n    }\n};"
      },
      "examples": [
        {
          "input": "prices = [7,1,5,3,6,4]",
          "output": "5",
          "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5"
        }
      ]
    },
    {
      "id": 13,
      "title": "Group Anagrams",
      "difficulty": "Medium",
      "topic": "Array, Hash Table, String, Sorting",
      "description": "Given an array of strings strs, group the anagrams together.",
      "algorithm": {
        "approach": "Hash Map with Sorted String Key",
        "steps": [
          "For each string, sort characters to create key",
          "Group strings with same sorted key",
          "Return all groups as result"
        ],
        "timeComplexity": "O(N * K log K)",
        "spaceComplexity": "O(N * K)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> mpp;\n        \n        for (string& s : strs) {\n            string key = s;\n            sort(key.begin(), key.end());\n            mpp[key].push_back(s);\n        }\n        \n        vector<vector<string>> result;\n        for (auto& pair : mpp) {\n            result.push_back(pair.second);\n        }\n        \n        return result;\n    }\n};"
      },
      "examples": [
        {
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "explanation": "Group strings that are anagrams"
        }
      ]
    },
    {
      "id": 14,
      "title": "K Closest Points to Origin",
      "difficulty": "Medium",
      "topic": "Array, Math, Divide and Conquer, Geometry, Sorting, Heap",
      "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).",
      "algorithm": {
        "approach": "Min Heap",
        "steps": [
          "Calculate distance for each point",
          "Use priority queue to maintain k closest points",
          "Return the k points with smallest distances"
        ],
        "timeComplexity": "O(n log k)",
        "spaceComplexity": "O(k)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\n        // Max heap to keep k closest points\n        priority_queue<pair<int, int>> pq;\n        \n        for (int i = 0; i < points.size(); i++) {\n            int dist = points[i][0] * points[i][0] + points[i][1] * points[i][1];\n            \n            if (pq.size() < k) {\n                pq.push({dist, i});\n            } else if (dist < pq.top().first) {\n                pq.pop();\n                pq.push({dist, i});\n            }\n        }\n        \n        vector<vector<int>> result;\n        while (!pq.empty()) {\n            result.push_back(points[pq.top().second]);\n            pq.pop();\n        }\n        \n        return result;\n    }\n};"
      },
      "examples": [
        {
          "input": "points = [[1,3],[-2,2]], k = 1",
          "output": "[[-2,2]]",
          "explanation": "Distance from origin: (1,3) = 10, (-2,2) = 8. Closer is (-2,2)"
        }
      ]
    },
    {
      "id": 15,
      "title": "Meeting Rooms II",
      "difficulty": "Medium",
      "topic": "Array, Two Pointers, Greedy, Sorting, Heap",
      "description": "Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.",
      "algorithm": {
        "approach": "Min Heap for End Times",
        "steps": [
          "Sort meetings by start time",
          "Use min heap to track end times of ongoing meetings",
          "For each meeting, remove ended meetings from heap",
          "Add current meeting's end time to heap",
          "Max heap size is the answer"
        ],
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    int minMeetingRooms(vector<vector<int>>& intervals) {\n        if (intervals.empty()) return 0;\n        \n        sort(intervals.begin(), intervals.end());\n        priority_queue<int, vector<int>, greater<int>> pq; // min heap\n        \n        for (auto& interval : intervals) {\n            // Remove meetings that have ended\n            if (!pq.empty() && pq.top() <= interval[0]) {\n                pq.pop();\n            }\n            // Add current meeting's end time\n            pq.push(interval[1]);\n        }\n        \n        return pq.size();\n    }\n};"
      },
      "examples": [
        {
          "input": "intervals = [[0,30],[5,10],[15,20]]",
          "output": "2",
          "explanation": "Need 2 rooms: one for [0,30], another for [5,10] and [15,20]"
        }
      ]
    },
    {
      "id": 16,
      "title": "Merge k Sorted Lists",
      "difficulty": "Hard",
      "topic": "Linked List, Divide and Conquer, Heap, Merge Sort",
      "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
      "algorithm": {
        "approach": "Min Heap",
        "steps": [
          "Use min heap to track current head of each list",
          "Extract minimum node and add to result",
          "Add next node from same list to heap",
          "Continue until all lists are processed"
        ],
        "timeComplexity": "O(n log k)",
        "spaceComplexity": "O(k)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };\n        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);\n        \n        // Add all non-null heads to heap\n        for (ListNode* head : lists) {\n            if (head) pq.push(head);\n        }\n        \n        ListNode dummy(0);\n        ListNode* curr = &dummy;\n        \n        while (!pq.empty()) {\n            ListNode* node = pq.top();\n            pq.pop();\n            \n            curr->next = node;\n            curr = curr->next;\n            \n            if (node->next) {\n                pq.push(node->next);\n            }\n        }\n        \n        return dummy.next;\n    }\n};"
      },
      "examples": [
        {
          "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
          "output": "[1,1,2,3,4,4,5,6]",
          "explanation": "Merge all sorted lists into one"
        }
      ]
    },
    {
      "id": 17,
      "title": "Trapping Rain Water",
      "difficulty": "Hard",
      "topic": "Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack",
      "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
      "algorithm": {
        "approach": "Two Pointers",
        "steps": [
          "Use two pointers from both ends",
          "Track max height seen from left and right",
          "Water level at position = min(leftMax, rightMax) - height",
          "Move pointer with smaller max height"
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    int trap(vector<int>& height) {\n        if (height.empty()) return 0;\n        \n        int left = 0, right = height.size() - 1;\n        int leftMax = 0, rightMax = 0;\n        int water = 0;\n        \n        while (left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] >= leftMax) {\n                    leftMax = height[left];\n                } else {\n                    water += leftMax - height[left];\n                }\n                left++;\n            } else {\n                if (height[right] >= rightMax) {\n                    rightMax = height[right];\n                } else {\n                    water += rightMax - height[right];\n                }\n                right--;\n            }\n        }\n        \n        return water;\n    }\n};"
      },
      "examples": [
        {
          "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
          "output": "6",
          "explanation": "Water trapped between the bars"
        }
      ]
    },
    {
      "id": 18,
      "title": "3Sum",
      "difficulty": "Medium",
      "topic": "Array, Two Pointers, Sorting",
      "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.",
      "algorithm": {
        "approach": "Sort + Two Pointers",
        "steps": [
          "Sort the array first",
          "Fix first element, use two pointers for remaining two",
          "Skip duplicates to avoid duplicate triplets",
          "Adjust pointers based on sum comparison with target"
        ],
        "timeComplexity": "O(n²)",
        "spaceComplexity": "O(1)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> result;\n        \n        for (int i = 0; i < nums.size() - 2; i++) {\n            // Skip duplicates for first element\n            if (i > 0 && nums[i] == nums[i-1]) continue;\n            \n            int left = i + 1, right = nums.size() - 1;\n            \n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                \n                if (sum == 0) {\n                    result.push_back({nums[i], nums[left], nums[right]});\n                    \n                    // Skip duplicates\n                    while (left < right && nums[left] == nums[left + 1]) left++;\n                    while (left < right && nums[right] == nums[right - 1]) right--;\n                    \n                    left++;\n                    right--;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return result;\n    }\n};"
      },
      "examples": [
        {
          "input": "nums = [-1,0,1,2,-1,-4]",
          "output": "[[-1,-1,2],[-1,0,1]]",
          "explanation": "All unique triplets that sum to 0"
        }
      ]
    },
    {
      "id": 19,
      "title": "Valid Parentheses",
      "difficulty": "Easy",
      "topic": "String, Stack",
      "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
      "algorithm": {
        "approach": "Stack",
        "steps": [
          "Use stack to track opening brackets",
          "For each closing bracket, check if it matches top of stack",
          "Return true if stack is empty at the end"
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> st;\n        \n        for (char c : s) {\n            if (c == '(' || c == '{' || c == '[') {\n                st.push(c);\n            } else {\n                if (st.empty()) return false;\n                \n                char top = st.top();\n                st.pop();\n                \n                if ((c == ')' && top != '(') ||\n                    (c == '}' && top != '{') ||\n                    (c == ']' && top != '[')) {\n                    return false;\n                }\n            }\n        }\n        \n        return st.empty();\n    }\n};"
      },
      "examples": [
        {
          "input": "s = \"()[]{}\"",
          "output": "true",
          "explanation": "All brackets are properly matched"
        },
        {
          "input": "s = \"([)]\"",
          "output": "false",
          "explanation": "Brackets are not properly nested"
        }
      ]
    },
    {
      "id": 20,
      "title": "Add Two Numbers",
      "difficulty": "Medium",
      "topic": "Linked List, Math, Recursion",
      "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
      "algorithm": {
        "approach": "Digit by Digit Addition",
        "steps": [
          "Traverse both lists simultaneously",
          "Add corresponding digits plus carry",
          "Create new node with sum % 10",
          "Update carry = sum / 10",
          "Handle remaining digits and final carry"
        ],
        "timeComplexity": "O(max(m,n))",
        "spaceComplexity": "O(max(m,n))"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy(0);\n        ListNode* curr = &dummy;\n        int carry = 0;\n        \n        while (l1 || l2 || carry) {\n            int sum = carry;\n            \n            if (l1) {\n                sum += l1->val;\n                l1 = l1->next;\n            }\n            \n            if (l2) {\n                sum += l2->val;\n                l2 = l2->next;\n            }\n            \n            carry = sum / 10;\n            curr->next = new ListNode(sum % 10);\n            curr = curr->next;\n        }\n        \n        return dummy.next;\n    }\n};"
      },
      "examples": [
        {
          "input": "l1 = [2,4,3], l2 = [5,6,4]",
          "output": "[7,0,8]",
          "explanation": "342 + 465 = 807"
        }
      ]
    },
    {
      "id": 21,
      "title": "Word Search",
      "difficulty": "Medium",
      "topic": "Array, Backtracking, Matrix",
      "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.",
      "algorithm": {
        "approach": "DFS Backtracking",
        "steps": [
          "Try starting from each cell in the grid",
          "Use DFS to explore all 4 directions",
          "Mark visited cells temporarily",
          "Backtrack by unmarking cells after exploring"
        ],
        "timeComplexity": "O(N * 4^L)",
        "spaceComplexity": "O(L)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int m = board.size(), n = board[0].size();\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dfs(board, word, i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \nprivate:\n    bool dfs(vector<vector<char>>& board, string& word, int i, int j, int idx) {\n        if (idx == word.length()) return true;\n        \n        if (i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || \n            board[i][j] != word[idx] || board[i][j] == '#') {\n            return false;\n        }\n        \n        char temp = board[i][j];\n        board[i][j] = '#'; // Mark as visited\n        \n        bool found = dfs(board, word, i+1, j, idx+1) ||\n                     dfs(board, word, i-1, j, idx+1) ||\n                     dfs(board, word, i, j+1, idx+1) ||\n                     dfs(board, word, i, j-1, idx+1);\n        \n        board[i][j] = temp; // Backtrack\n        return found;\n    }\n};"
      },
      "examples": [
        {
          "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
          "output": "true",
          "explanation": "Word exists in the grid"
        }
      ]
    },
    {
      "id": 22,
      "title": "Maximum Subarray",
      "difficulty": "Medium",
      "topic": "Array, Divide and Conquer, Dynamic Programming",
      "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.",
      "algorithm": {
        "approach": "Kadane's Algorithm",
        "steps": [
          "Track current sum and maximum sum",
          "For each element, decide to extend current subarray or start new",
          "Current sum = max(current element, current sum + current element)",
          "Update maximum sum found so far"
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int maxSum = nums[0], currSum = nums[0];\n        \n        for (int i = 1; i < nums.size(); i++) {\n            // Either extend current subarray or start new\n            currSum = max(nums[i], currSum + nums[i]);\n            maxSum = max(maxSum, currSum);\n        }\n        \n        return maxSum;\n    }\n};"
      },
      "examples": [
        {
          "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
          "output": "6",
          "explanation": "Subarray [4,-1,2,1] has the largest sum 6"
        }
      ]
    },
    {
      "id": 23,
      "title": "Search Suggestions System",
      "difficulty": "Medium",
      "topic": "Array, String, Trie",
      "description": "You are given an array of strings products and a string searchWord. Design a system that suggests at most three product names from products after each character of searchWord is typed.",
      "algorithm": {
        "approach": "Sort + Binary Search",
        "steps": [
          "Sort products array",
          "For each prefix, find first matching product using binary search",
          "Collect up to 3 products starting from that position",
          "Filter products that don't match current prefix"
        ],
        "timeComplexity": "O(n log n + m*n)",
        "spaceComplexity": "O(1)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    vector<vector<string>> suggestedProducts(vector<string>& products, string searchWord) {\n        sort(products.begin(), products.end());\n        vector<vector<string>> result;\n        string prefix = \"\";\n        \n        for (char c : searchWord) {\n            prefix += c;\n            vector<string> suggestions;\n            \n            // Find first product with current prefix\n            auto it = lower_bound(products.begin(), products.end(), prefix);\n            \n            // Collect up to 3 matching products\n            for (int i = 0; i < 3 && it + i != products.end(); i++) {\n                string& product = *(it + i);\n                if (product.length() >= prefix.length() && \n                    product.substr(0, prefix.length()) == prefix) {\n                    suggestions.push_back(product);\n                } else {\n                    break;\n                }\n            }\n            \n            result.push_back(suggestions);\n        }\n        \n        return result;\n    }\n};"
      },
      "examples": [
        {
          "input": "products = [\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"], searchWord = \"mouse\"",
          "output": "[[\"mobile\",\"moneypot\",\"monitor\"],[\"mobile\",\"moneypot\",\"monitor\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"]]",
          "explanation": "Suggestions for each prefix of 'mouse'"
        }
      ]
    },
    {
      "id": 24,
      "title": "Median of Two Sorted Arrays",
      "difficulty": "Hard",
      "topic": "Array, Binary Search, Divide and Conquer",
      "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.",
      "algorithm": {
        "approach": "Binary Search",
        "steps": [
          "Ensure nums1 is the smaller array",
          "Binary search on nums1 to find correct partition",
          "Partition such that left half has (m+n+1)/2 elements",
          "Check if partition is valid and calculate median"
        ],
        "timeComplexity": "O(log(min(m,n)))",
        "spaceComplexity": "O(1)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int m = nums1.size(), n = nums2.size();\n        int left = 0, right = m;\n        \n        while (left <= right) {\n            int cut1 = (left + right) / 2;\n            int cut2 = (m + n + 1) / 2 - cut1;\n            \n            int left1 = (cut1 == 0) ? INT_MIN : nums1[cut1 - 1];\n            int left2 = (cut2 == 0) ? INT_MIN : nums2[cut2 - 1];\n            \n            int right1 = (cut1 == m) ? INT_MAX : nums1[cut1];\n            int right2 = (cut2 == n) ? INT_MAX : nums2[cut2];\n            \n            if (left1 <= right2 && left2 <= right1) {\n                if ((m + n) % 2 == 0) {\n                    return (max(left1, left2) + min(right1, right2)) / 2.0;\n                } else {\n                    return max(left1, left2);\n                }\n            } else if (left1 > right2) {\n                right = cut1 - 1;\n            } else {\n                left = cut1 + 1;\n            }\n        }\n        \n        return 1.0;\n    }\n};"
      },
      "examples": [
        {
          "input": "nums1 = [1,3], nums2 = [2]",
          "output": "2.0",
          "explanation": "Merged array = [1,2,3], median = 2"
        }
      ]
    },
    {
      "id": 25,
      "title": "Keys and Rooms",
      "difficulty": "Medium",
      "topic": "Depth-First Search, Breadth-First Search, Graph",
      "description": "There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms.",
      "algorithm": {
        "approach": "DFS/BFS",
        "steps": [
          "Start from room 0 (unlocked)",
          "Use DFS/BFS to visit reachable rooms",
          "Collect keys from visited rooms",
          "Check if all rooms are visited"
        ],
        "timeComplexity": "O(N + E)",
        "spaceComplexity": "O(N)"
      },
      "code": {
        "language": "cpp",
        "solution": "class Solution {\npublic:\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\n        unordered_set<int> visited;\n        stack<int> st;\n        st.push(0);\n        \n        while (!st.empty()) {\n            int room = st.top();\n            st.pop();\n            \n            if (visited.count(room)) continue;\n            visited.insert(room);\n            \n            // Add all keys from current room\n            for (int key : rooms[room]) {\n                if (!visited.count(key)) {\n                    st.push(key);\n                }\n            }\n        }\n        \n        return visited.size() == rooms.size();\n    }\n};"
      },
      "examples": [
        {
          "input": "rooms = [[1],[2],[3],[]]",
          "output": "true",
          "explanation": "Start in room 0, get key 1, go to room 1, get key 2, etc."
        }
      ]
    }
  ,
    {
      "id": 26,
      "title": "Nearest Smaller Element (Monotonic Stack)",
      "difficulty": "Medium",
      "topic": "Array, Stack, Monotonic Stack",
      "description": "For each element in the array, find the nearest smaller element to its left. If none, return -1 for that position.",
      "algorithm": {
        "approach": "Monotonic Stack",
        "steps": [
          "Iterate through array from left to right",
          "Use stack to keep track of indices of elements in increasing order",
          "For each element, pop from stack until top is smaller or stack is empty",
          "Nearest smaller is stack top or -1 if stack is empty"
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      "code": {
        "language": "cpp",
        "solution": "vector<int> nearestSmaller(vector<int>& a) {\n    vector<int> res(a.size(), -1);\n    stack<int> st;\n    for (int i = 0; i < a.size(); i++) {\n        while (!st.empty() && a[st.top()] >= a[i]) st.pop();\n        if (!st.empty()) res[i] = a[st.top()];\n        st.push(i);\n    }\n    return res;\n}"
      },
      "examples": [
        {
          "input": "a = [4, 5, 2, 10, 8]",
          "output": "[-1, 4, -1, 2, 2]",
          "explanation": "For 4: -1, 5: 4, 2: -1, 10: 2, 8: 2"
        }
      ]
    },
    {
      "id": 27,
      "title": "Shortest Safe Path (Matrix BFS)",
      "difficulty": "Medium",
      "topic": "Matrix, BFS, Shortest Path",
      "description": "Given a matrix with safe (1) and unsafe (0) cells, find the shortest path from any cell in the first column to any cell in the last column, moving only through safe cells.",
      "algorithm": {
        "approach": "BFS from All First Column Safe Cells",
        "steps": [
          "For each safe cell in the first column, start BFS",
          "Track visited cells to avoid cycles",
          "For each move, only go to safe, unvisited cells",
          "Return minimum path length to any last column cell"
        ],
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(m*n)"
      },
      "code": {
        "language": "cpp",
        "solution": "int shortestSafePath(vector<vector<int>>& mat) {\n    int m = mat.size(), n = mat[0].size();\n    queue<pair<int,int>> q;\n    vector<vector<int>> vis(m, vector<int>(n, 0));\n    for (int i = 0; i < m; i++) {\n        if (mat[i][0] == 1) {\n            q.push({i, 0});\n            vis[i][0] = 1;\n        }\n    }\n    int steps = 0;\n    int dirs[4][2] = {{0,1},{1,0},{-1,0},{0,-1}};\n    while (!q.empty()) {\n        int sz = q.size();\n        while (sz--) {\n            auto [x, y] = q.front(); q.pop();\n            if (y == n-1) return steps;\n            for (auto& d : dirs) {\n                int nx = x + d[0], ny = y + d[1];\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && mat[nx][ny] == 1 && !vis[nx][ny]) {\n                    vis[nx][ny] = 1;\n                    q.push({nx, ny});\n                }\n            }\n        }\n        steps++;\n    }\n    return -1;\n}"
      },
      "examples": [
        {
          "input": "mat = [[1,1,1,1],[0,1,0,1],[1,1,1,1],[1,0,1,1]]",
          "output": "3",
          "explanation": "Shortest safe path from first to last column is length 3"
        }
      ]
    },
    {
      "id": 28,
      "title": "Maximize Equal-Cost Packages (Greedy)",
      "difficulty": "Medium",
      "topic": "Array, Greedy, Math",
      "description": "Given an array of package costs, split them into two groups with equal total cost. Return the maximum number of packages in either group. If not possible, return -1.",
      "algorithm": {
        "approach": "Subset Sum with Greedy",
        "steps": [
          "Calculate total sum, if odd return -1",
          "Use DP to check if subset sum = total/2 is possible",
          "Track max number of packages in such a subset"
        ],
        "timeComplexity": "O(n*sum/2)",
        "spaceComplexity": "O(sum/2)"
      },
      "code": {
        "language": "cpp",
        "solution": "int maxEqualPackages(vector<int>& a) {\n    int n = a.size(), sum = accumulate(a.begin(), a.end(), 0);\n    if (sum % 2) return -1;\n    int target = sum / 2;\n    vector<int> dp(target+1, -1);\n    dp[0] = 0;\n    for (int x : a) {\n        for (int j = target; j >= x; j--) {\n            if (dp[j-x] != -1) dp[j] = max(dp[j], dp[j-x]+1);\n        }\n    }\n    return dp[target] == -1 ? -1 : dp[target];\n}"
      },
      "examples": [
        {
          "input": "a = [1,5,11,5]",
          "output": "2",
          "explanation": "Split into [11] and [1,5,5], both sum to 11, max group size is 2"
        }
      ]
    },
    {
      "id": 29,
      "title": "Checksum Distinct Values (Hash Set)",
      "difficulty": "Easy",
      "topic": "Array, Hash Set",
      "description": "Given an array of integers, return the sum of all distinct values.",
      "algorithm": {
        "approach": "Hash Set",
        "steps": [
          "Insert all elements into a set",
          "Sum all elements in the set"
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      "code": {
        "language": "cpp",
        "solution": "int checksumDistinct(vector<int>& a) {\n    unordered_set<int> s(a.begin(), a.end());\n    int sum = 0;\n    for (int x : s) sum += x;\n    return sum;\n}"
      },
      "examples": [
        {
          "input": "a = [1,2,2,3,4,4]",
          "output": "10",
          "explanation": "Distinct values are 1,2,3,4, sum is 10"
        }
      ]
    },
    {
      "id": 30,
      "title": "Minimum Window Substring",
      "difficulty": "Hard",
      "topic": "Hash Table, String, Sliding Window",
      "description": "Given two strings s and t, return the minimum window in s which contains all the characters of t. If no such window exists, return the empty string.",
      "algorithm": {
        "approach": "Sliding Window with Hash Map",
        "steps": [
          "Count frequency of each character in t",
          "Expand window by moving right pointer, include characters",
          "When all required characters are included, try to shrink from left",
          "Track minimum window length and position"
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      "code": {
        "language": "cpp",
        "solution": "string minWindow(string s, string t) {\n    vector<int> need(128, 0);\n    for (char c : t) need[c]++;\n    int left = 0, cnt = 0, minLen = INT_MAX, start = 0;\n    for (int right = 0; right < s.size(); right++) {\n        if (--need[s[right]] >= 0) cnt++;\n        while (cnt == t.size()) {\n            if (right - left + 1 < minLen) minLen = right - left + 1, start = left;\n            if (++need[s[left++]] > 0) cnt--;\n        }\n    }\n    return minLen == INT_MAX ? \\\"\\\" : s.substr(start, minLen);\n}"
  },
      "examples": [
        {
          "input": "s = 'ADOBECODEBANC', t = 'ABC'",
          "output": "'BANC'",
          "explanation": "Smallest window containing A, B, C is 'BANC'"
        }
      ]
    },
    {
      "id": 31,
      "title": "Find Peak Element",
      "difficulty": "Medium",
      "topic": "Array, Binary Search",
      "description": "A peak element is an element that is strictly greater than its neighbors. Given an integer array nums, find a peak element and return its index.",
      "algorithm": {
        "approach": "Binary Search",
        "steps": [
          "Use binary search to find a peak",
          "Compare middle element with neighbors",
          "Move to side with greater neighbor",
          "Return index when peak is found"
        ],
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)"
      },
      "code": {
        "language": "cpp",
        "solution": "int findPeakElement(vector<int>& a) {\n    int l = 0, r = a.size() - 1;\n    while (l < r) {\n        int m = (l + r) / 2;\n        if (a[m] < a[m+1]) l = m + 1;\n        else r = m;\n    }\n    return l;\n}"
      },
      "examples": [
        {
          "input": "a = [1,2,3,1]",
          "output": "2",
          "explanation": "Element at index 2 (3) is a peak"
        }
      ]
    },
    {
      "id": 32,
      "title": "Subarray Sum Equals K",
      "difficulty": "Medium",
      "topic": "Array, Hash Map, Prefix Sum",
      "description": "Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k.",
      "algorithm": {
        "approach": "Prefix Sum with Hash Map",
        "steps": [
          "Use hash map to store prefix sum counts",
          "Iterate through array, update prefix sum",
          "For each prefix sum, check if (sum - k) exists in map",
          "Increment result by count of (sum - k)"
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      "code": {
        "language": "cpp",
        "solution": "int subarraySum(vector<int>& a, int k) {\n    unordered_map<int, int> m;\n    m[0] = 1;\n    int sum = 0, res = 0;\n    for (int x : a) {\n        sum += x;\n        res += m[sum - k];\n        m[sum]++;\n    }\n    return res;\n}"
      },
      "examples": [
        {
          "input": "a = [1,1,1], k = 2",
          "output": "2",
          "explanation": "Two subarrays sum to 2: [1,1] at positions 0-1 and 1-2"
        }
      ]
    },
    {
      "id": 33,
      "title": "Course Schedule",
      "difficulty": "Medium",
      "topic": "Graph, Topological Sort, BFS",
      "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1. Some courses have prerequisites. Return true if you can finish all courses.",
      "algorithm": {
        "approach": "Topological Sort (BFS)",
        "steps": [
          "Build graph and in-degree array from prerequisites",
          "Add all nodes with in-degree 0 to queue",
          "Process queue, decrement in-degree of neighbors",
          "If all courses processed, return true"
        ],
        "timeComplexity": "O(V+E)",
        "spaceComplexity": "O(V+E)"
      },
      "code": {
        "language": "cpp",
        "solution": "bool canFinish(int n, vector<vector<int>>& pre) {\n    vector<vector<int>> g(n);\n    vector<int> deg(n, 0);\n    for (auto& p : pre) {\n        g[p[1]].push_back(p[0]);\n        deg[p[0]]++;\n    }\n    queue<int> q;\n    for (int i = 0; i < n; i++) if (!deg[i]) q.push(i);\n    int cnt = 0;\n    while (!q.empty()) {\n        int u = q.front(); q.pop(); cnt++;\n        for (int v : g[u]) if (--deg[v] == 0) q.push(v);\n    }\n    return cnt == n;\n}"
      },
      "examples": [
        {
          "input": "n = 2, pre = [[1,0]]",
          "output": "true",
          "explanation": "Can finish all courses by taking 0 then 1"
        }
      ]
    },
    {
      "id": 38,
      "title": "Search in Rotated Sorted Array",
      "difficulty": "Medium",
      "topic": "Array, Binary Search",
      "description": "Given the array nums after the rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.",
      "algorithm": {
        "approach": "Modified Binary Search",
        "steps": [
          "Use binary search, check which half is sorted",
          "If left half is sorted and target in range, search left",
          "Else search right half",
          "Repeat until found or search space is empty"
        ],
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)"
      },
      "code": {
        "language": "cpp",
        "solution": "int search(vector<int>& a, int t) {\n    int l = 0, r = a.size() - 1;\n    while (l <= r) {\n        int m = (l + r) / 2;\n        if (a[m] == t) return m;\n        if (a[l] <= a[m]) {\n            if (a[l] <= t && t < a[m]) r = m - 1;\n            else l = m + 1;\n        } else {\n            if (a[m] < t && t <= a[r]) l = m + 1;\n            else r = m - 1;\n        }\n    }\n    return -1;\n}"
      },
      "examples": [
        {
          "input": "a = [4,5,6,7,0,1,2], t = 0",
          "output": "4",
          "explanation": "0 is at index 4"
        }
      ]
    },
    {
      "id": 39,
      "title": "Combination Sum",
      "difficulty": "Medium",
      "topic": "Array, Backtracking",
      "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target.",
      "algorithm": {
        "approach": "Backtracking",
        "steps": [
          "Sort candidates for pruning",
          "Use backtracking to try each candidate",
          "If sum exceeds target, backtrack",
          "If sum equals target, add combination to result"
        ],
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n)"
      },
      "code": {
        "language": "cpp",
        "solution": "void dfs(vector<int>& a, int t, int i, vector<int>& cur, vector<vector<int>>& res) {\n    if (t == 0) { res.push_back(cur); return; }\n    for (int j = i; j < a.size() && a[j] <= t; j++) {\n        cur.push_back(a[j]);\n        dfs(a, t - a[j], j, cur, res);\n        cur.pop_back();\n    }\n}\nvector<vector<int>> combinationSum(vector<int>& a, int t) {\n    sort(a.begin(), a.end());\n    vector<vector<int>> res;\n    vector<int> cur;\n    dfs(a, t, 0, cur, res);\n    return res;\n}"
      },
      "examples": [
        {
          "input": "a = [2,3,6,7], t = 7",
          "output": "[[2,2,3],[7]]",
          "explanation": "All unique combinations that sum to 7"
        }
      ]
    },
    {
      "id": 40,
      "title": "Insert Interval",
      "difficulty": "Medium",
      "topic": "Array, Sorting",
      "description": "Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).",
      "algorithm": {
        "approach": "Linear Scan and Merge",
        "steps": [
          "Add all intervals before new interval",
          "Merge overlapping intervals with new interval",
          "Add remaining intervals after new interval"
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      "code": {
        "language": "cpp",
        "solution": "vector<vector<int>> insert(vector<vector<int>>& a, vector<int>& ni) {\n    vector<vector<int>> res;\n    int i = 0, n = a.size();\n    while (i < n && a[i][1] < ni[0]) res.push_back(a[i++]);\n    while (i < n && a[i][0] <= ni[1]) {\n        ni[0] = min(ni[0], a[i][0]);\n        ni[1] = max(ni[1], a[i][1]);\n        i++;\n    }\n    res.push_back(ni);\n    while (i < n) res.push_back(a[i++]);\n    return res;\n}"
      },
      "examples": [
        {
          "input": "a = [[1,3],[6,9]], ni = [2,5]",
          "output": "[[1,5],[6,9]]",
          "explanation": "Merge [2,5] with [1,3]"
        }
      ]
    },
    {
      "id": 41,
      "title": "Find Minimum in Rotated Sorted Array",
      "difficulty": "Medium",
      "topic": "Array, Binary Search",
      "description": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. Find the minimum element.",
      "algorithm": {
        "approach": "Binary Search",
        "steps": [
          "Use binary search to find inflection point",
          "If mid element > right, min is in right half",
          "Else min is in left half",
          "Return the minimum found"
        ],
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)"
      },
      "code": {
        "language": "cpp",
        "solution": "int findMin(vector<int>& a) {\n    int l = 0, r = a.size() - 1;\n    while (l < r) {\n        int m = (l + r) / 2;\n        if (a[m] > a[r]) l = m + 1;\n        else r = m;\n    }\n    return a[l];\n}"
      },
      "examples": [
        {
          "input": "a = [3,4,5,1,2]",
          "output": "1",
          "explanation": "1 is the minimum element"
        }
      ]
    },
    {
      "id": 34,
      "title": "Clone Graph",
      "difficulty": "Medium",
      "topic": "Graph, DFS, BFS, Hash Map",
      "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph.",
      "algorithm": {
        "approach": "DFS with Hash Map",
        "steps": [
          "Use a hash map to store cloned nodes",
          "For each node, recursively clone neighbors",
          "Return the cloned node for each original node"
        ],
        "timeComplexity": "O(N)",
        "spaceComplexity": "O(N)"
      },
      "code": {
        "language": "cpp",
        "solution": "Node* cloneGraph(Node* node) {\n    if (!node) return nullptr;\n    unordered_map<Node*, Node*> m;\n    function<Node*(Node*)> dfs = [&](Node* n) {\n        if (m.count(n)) return m[n];\n        Node* copy = new Node(n->val);\n        m[n] = copy;\n        for (Node* nei : n->neighbors) copy->neighbors.push_back(dfs(nei));\n        return copy;\n    };\n    return dfs(node);\n}"
      },
      "examples": [
        {
          "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]",
          "output": "[[2,4],[1,3],[2,4],[1,3]]",
          "explanation": "Graph is cloned with same structure"
        }
      ]
    },
    {
      "id": 35,
      "title": "Product of Array Except Self",
      "difficulty": "Medium",
      "topic": "Array, Prefix Product",
      "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].",
      "algorithm": {
        "approach": "Prefix and Suffix Product",
        "steps": [
          "Compute prefix products for each index",
          "Compute suffix products for each index",
          "Multiply prefix and suffix for each index to get result"
        ],
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1) (output array not counted)"
      },
      "code": {
        "language": "cpp",
        "solution": "vector<int> productExceptSelf(vector<int>& a) {\n    int n = a.size();\n    vector<int> res(n, 1);\n    int left = 1, right = 1;\n    for (int i = 0; i < n; i++) {\n        res[i] *= left;\n        left *= a[i];\n    }\n    for (int i = n-1; i >= 0; i--) {\n        res[i] *= right;\n        right *= a[i];\n    }\n    return res;\n}"
      },
      "examples": [
        {
          "input": "a = [1,2,3,4]",
          "output": "[24,12,8,6]",
          "explanation": "Product except self for each index"
        }
      ]
    },
    {
      "id": 36,
      "title": "Spiral Matrix",
      "difficulty": "Medium",
      "topic": "Array, Matrix, Simulation",
      "description": "Given an m x n matrix, return all elements of the matrix in spiral order.",
      "algorithm": {
        "approach": "Layer by Layer Traversal",
        "steps": [
          "Define boundaries for top, bottom, left, right",
          "Traverse each layer in spiral order",
          "Shrink boundaries after each layer"
        ],
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(1) (output array not counted)"
      },
      "code": {
        "language": "cpp",
        "solution": "vector<int> spiralOrder(vector<vector<int>>& mat) {\n    vector<int> res;\n    int m = mat.size(), n = mat[0].size();\n    int top = 0, bot = m-1, left = 0, right = n-1;\n    while (top <= bot && left <= right) {\n        for (int j = left; j <= right; j++) res.push_back(mat[top][j]);\n        top++;\n        for (int i = top; i <= bot; i++) res.push_back(mat[i][right]);\n        right--;\n        if (top <= bot) for (int j = right; j >= left; j--) res.push_back(mat[bot][j]);\n        bot--;\n        if (left <= right) for (int i = bot; i >= top; i--) res.push_back(mat[i][left]);\n        left++;\n    }\n    return res;\n}"
      },
      "examples": [
        {
          "input": "mat = [[1,2,3],[4,5,6],[7,8,9]]",
          "output": "[1,2,3,6,9,8,7,4,5]",
          "explanation": "Spiral order traversal of matrix"
        }
      ]
    },
    {
      "id": 37,
      "title": "Set Matrix Zeroes",
      "difficulty": "Medium",
      "topic": "Array, Matrix, Hash Set",
      "description": "Given an m x n integer matrix, if an element is 0, set its entire row and column to 0 in-place.",
      "algorithm": {
        "approach": "Use First Row and Column as Markers",
        "steps": [
          "Check if first row and column need to be zeroed",
          "Use first row and column to mark zero rows/columns",
          "Zero out marked rows and columns",
          "Zero first row/column if needed"
        ],
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(1)"
      },
      "code": {
        "language": "cpp",
        "solution": "void setZeroes(vector<vector<int>>& mat) {\n    int m = mat.size(), n = mat[0].size();\n    bool row0 = false, col0 = false;\n    for (int i = 0; i < m; i++) if (mat[i][0] == 0) col0 = true;\n    for (int j = 0; j < n; j++) if (mat[0][j] == 0) row0 = true;\n    for (int i = 1; i < m; i++) for (int j = 1; j < n; j++) if (mat[i][j] == 0) mat[i][0] = mat[0][j] = 0;\n    for (int i = 1; i < m; i++) for (int j = 1; j < n; j++) if (mat[i][0] == 0 || mat[0][j] == 0) mat[i][j] = 0;\n    if (row0) for (int j = 0; j < n; j++) mat[0][j] = 0;\n    if (col0) for (int i = 0; i < m; i++) mat[i][0] = 0;\n}"
      },
      "examples": [
        {
          "input": "mat = [[1,1,1],[1,0,1],[1,1,1]]",
          "output": "[[1,0,1],[0,0,0],[1,0,1]]",
          "explanation": "Row 1 and column 1 set to zero"
        }
    ]
    }
]
}
